# 제어자(modifier)

### 제어자(modifier)

클래스, 멤버변수와 메서드에 주로 사용됨.

하나의 대상에 여러 제어자를 조합하여 사용하는 것이 가능

단, 접근 제어자는 한번에 한 가지만 사용 가능

### static

클래스변수 == static 멤버 변수

하나의 변수를 모든 인스턴스가 공유

→ class loader를 통해 jvm의 **Runtime Data Area > Method Area** 로 적재됨

→ java 8버전 부터 OS의 Metaspace라는 곳에 적재되어짐.

클래스를 사용하기 이전에 이 변수들은 미리 메모리를 할당 받음.

- **static이 사용될 수 있는 곳 - 멤버 변수, 메서드, 초기화 블럭**

| 인스턴스 메서드 | static 메서드 |
| --- | --- |
| 메서드 내에서 인스턴스 멤버 사용 | 메서드 내에서 인스턴스 멤버 사용 X |

| 제어자 | 대상 | 의미 |
| --- | --- | --- |
| static | 멤버 변수 | - 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다. |
|  |  | - 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다 |
|  |  | - 클래스가 메모리에 로드 될 때 생성된다. |
|  | 메서드 | - 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다. |
|  |  | - static 메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다. (method area에 클래스 메타데이터가 로드 될 때 인스턴스 멤버들은 선언되지 않는다.) |
- 인스턴스 변수를 사용하지 않는 메서드는 static 메서드로 선언하는 것을 고려하도록 하자!
- 인스턴스를 생성하지 않고도 호출 가능해서 더 편리하고 속도도 더 빠르다.

### 접근 제어자(access modifier)

멤버 또는 클래스에 사용됨.

- **접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버 변수, 메서드, 생성자**

**public** - 접근 제한이 전혀 없다.

**protected** - 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능하다.

(**default**) - 같은 패키지 내에서만 접근이 가능하다.

**private** - 같은 클래스 내에서만 접근이 가능하다.

**접근 제어자를 이용한** ***캡슐화***

접근 제어자를 사용하는 이유

- 외부로부터 데이터를 보호하기 위해서
- 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서

*접근 가능 범위가 넓을 수록 사용 범위가 넓어지기 때문에 테스트(고려)해야 되는 범위가 넓어짐.

**생성자의 접근 제어자**

생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다.

생성자의 접근 제어자를 private으로 지정하면, 외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없게 된다.

생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없음.

- 자손 클래스의 인스턴스를 생성할 때 조상 클래스의 생성자를 호출해야만 하는데, 생성자의 접근 제어자가 private이므로 자손 클래스에서 호출하는 것이 불가능하기 때문이다.
- 클래스 앞에 final을 더 추가 하여 상속할 수 없는 클래스라는 것을 알리는 것이 좋다.

<활용 예 - Singleton Pattern>

```java
public final class Singleton{
		
	private static Singleton singleton = new Singleton();	

	private Singleton {}

	public static Singleton getInstance(){
		//인스턴스를 생성하지 않고 호출할 수 있어야 하기 때문에 static 이어야 함.
		if(singleton == null){
			singleton = new Singleton();
		}
		return singleton;
	}
}
```

**제어자의 조합**

제어자를 조합해서 사용할 때 주의해야 할 사항

1. **메서드에 static과 abstract를 함께 사용할 수 없다.**
    
    static 메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문이다.
    
2. **클래스에 abstract와 final을 동시에 사용할 수 없다.**
    
    클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고 abstract는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순되기 때문이다.
    
3. **abstract메서드의 접근 제어자가 private일 수 없다.**
    
    abstract메서드는 자손 클래스에서 구현해주어야 하는데 접근 제어자가 private이면, 자손 클래스에서 접근할 수 없기 때문이다.
    
4. **메서드에 private과 final을 같이 사용할 필요는 없다.**
    
    접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문이다. 이 둘 중 하나만 사용해도 의미가 충분하다.
    

<참조>

남궁 성, 『Java의 정석 3판』, 도우출판(2016),p344-353.